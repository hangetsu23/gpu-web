<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <title>Portfolio</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html,body{height:100%;margin:0;font-family:Arial,sans-serif} 
    canvas{display:block}
    #info{position:absolute;top:10px;left:10px;color:white;background:rgba(0,0,0,0.7);padding:10px;border-radius:5px;font-size:14px;max-width:300px}
  </style>

  <!-- ‡πÇ‡∏´‡∏•‡∏î Three.js + Loader ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏° -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/RGBELoader.js"></script>
</head>
<body>
<div id="info">
  ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏• 3D...<br>
  <small>‡πÉ‡∏ä‡πâ‡πÄ‡∏°‡∏≤‡∏™‡πå‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏´‡∏°‡∏∏‡∏ô‡πÅ‡∏•‡∏∞‡∏ã‡∏π‡∏°</small>
</div>

<script>
  // Scene / Camera / Renderer
  const scene = new THREE.Scene();

  const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 100);
  camera.position.set(0, 2, 5);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(innerWidth, innerHeight);
  renderer.outputEncoding = THREE.sRGBEncoding;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.2;
  renderer.physicallyCorrectLights = true;
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  document.body.appendChild(renderer.domElement);

  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;

  // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏û‡∏∑‡πâ‡∏ô
  const floorGeometry = new THREE.PlaneGeometry(20, 20);
  const floorMaterial = new THREE.MeshStandardMaterial({ 
    color: 0x404040,
    roughness: 0.8,
    metalness: 0.2
  });
  const floor = new THREE.Mesh(floorGeometry, floorMaterial);
  floor.rotation.x = -Math.PI / 2;
  floor.receiveShadow = true;
  scene.add(floor);

  // ‡πÅ‡∏™‡∏á‡∏´‡∏•‡∏±‡∏Å
  const directionalLight = new THREE.DirectionalLight(0xffffff, 2);
  directionalLight.position.set(5, 10, 5);
  directionalLight.castShadow = true;
  scene.add(directionalLight);

  const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
  scene.add(ambientLight);

  // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÅ‡∏™‡∏á‡πÄ‡∏™‡∏£‡∏¥‡∏°
  const fillLight1 = new THREE.DirectionalLight(0xffffff, 1);
  fillLight1.position.set(-5, 5, -5);
  scene.add(fillLight1);

  const fillLight2 = new THREE.DirectionalLight(0xffffff, 0.8);
  fillLight2.position.set(0, 5, -5);
  scene.add(fillLight2);

  // ‚úÖ ‡πÇ‡∏´‡∏•‡∏î HDRI ‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô environment + background
  const pmremGenerator = new THREE.PMREMGenerator(renderer);
  new THREE.RGBELoader()
    .setDataType(THREE.UnsignedByteType)
    .load("https://hangetsu23.github.io/gpu-web/Portfolio/meadow_2_2k.hdr", function(hdr) {
      const envMap = pmremGenerator.fromEquirectangular(hdr).texture;
      scene.background = envMap;
      scene.environment = envMap;
    });

  // ‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏• GLB
  const loader = new THREE.GLTFLoader();
  let model = null;
  
  const modelUrl = 'https://hangetsu23.github.io/gpu-web/Portfolio/main.glb';
  
  loader.load(
    modelUrl,
    function (gltf) {
      model = gltf.scene;
      model.position.y = 0;
      model.scale.setScalar(1);
      
      let meshCount = 0;
      let materialInfo = [];
      
      // üî• ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç Material ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
      model.traverse(function (child) {
        if (child.isMesh) {
          meshCount++;
          child.castShadow = true;
          child.receiveShadow = true;
          
          console.log('Mesh name:', child.name);
          
          if (child.material) {
            const mat = child.material;
            const hasTexture = mat.map !== null && mat.map !== undefined;
            
            materialInfo.push(`${child.name}: ${hasTexture ? '‡∏°‡∏µ texture' : '‡πÑ‡∏°‡πà‡∏°‡∏µ texture'}`);
            console.log(`  - Material:`, mat);
            console.log(`  - Has texture:`, hasTexture);
            console.log(`  - Color:`, mat.color ? mat.color.getHexString() : 'N/A');
            
            // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ texture ‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏õ‡πá‡∏ô‡∏™‡∏µ‡∏Ç‡∏≤‡∏ß ‡πÉ‡∏´‡πâ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÉ‡∏´‡∏°‡πà
            if (!hasTexture || (mat.color && mat.color.getHex() === 0xffffff)) {
              let newColor = 0x808080; // ‡∏™‡∏µ‡πÄ‡∏ó‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
              
              // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏™‡∏µ‡∏ï‡∏≤‡∏°‡∏ä‡∏∑‡πà‡∏≠ object (‡∏ï‡∏≤‡∏°‡πÇ‡∏°‡πÄ‡∏î‡∏• Blender)
              const name = child.name.toLowerCase();
              
              // ‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ï‡∏≤‡∏° mesh number
              if (name.includes('mesh006_1')) {
                newColor = 0xF5E6D3; // ‡∏´‡∏•‡∏±‡∏á‡∏Ñ‡∏≤ - ‡∏™‡∏µ‡∏Ñ‡∏£‡∏µ‡∏°‡∏≠‡πà‡∏≠‡∏ô
              } else if (name.includes('mesh006_2')) {
                newColor = 0x8B3A3A; // ‡∏ù‡∏≤‡∏ú‡∏ô‡∏±‡∏á - ‡∏™‡∏µ‡∏ô‡πâ‡∏≥‡∏ï‡∏≤‡∏•‡πÅ‡∏î‡∏á
              } else if (name.includes('mesh006_3')) {
                newColor = 0xD2691E; // ‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á - ‡∏™‡∏µ‡πÑ‡∏°‡πâ
              } else if (name.includes('mesh006_4')) {
                newColor = 0xF5DEB3; // ‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î - ‡∏™‡∏µ‡πÄ‡∏ö‡∏à
              } else if (name.includes('mesh006_5')) {
                newColor = 0xCD853F; // ‡πÄ‡∏™‡∏≤ - ‡∏™‡∏µ‡∏ô‡πâ‡∏≥‡∏ï‡∏≤‡∏•‡∏≠‡πà‡∏≠‡∏ô
              } else if (name.includes('tanah') || name.includes('plane')) {
                newColor = 0x5A8F3A; // ‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏ç‡πâ‡∏≤ - ‡∏™‡∏µ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß
              } else if (name.includes('sumur')) {
                newColor = 0xC0C0C0; // ‡∏ö‡πà‡∏≠‡∏ô‡πâ‡∏≥ - ‡∏™‡∏µ‡πÄ‡∏ó‡∏≤‡∏≠‡πà‡∏≠‡∏ô
              } else if (name.includes('mesh003')) {
                newColor = 0x696969; // ‡∏™‡πà‡∏ß‡∏ô‡∏ï‡∏Å‡πÅ‡∏ï‡πà‡∏á - ‡∏™‡∏µ‡πÄ‡∏ó‡∏≤‡πÄ‡∏Ç‡πâ‡∏°
              } else {
                // ‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ
                newColor = 0xD2B48C; // ‡∏™‡∏µ‡∏ô‡πâ‡∏≥‡∏ï‡∏≤‡∏•‡∏≠‡πà‡∏≠‡∏ô
              }
              
              console.log(`  ‚ö†Ô∏è ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÄ‡∏õ‡πá‡∏ô‡∏™‡∏µ: #${newColor.toString(16)}`);
              
              child.material = new THREE.MeshStandardMaterial({
                color: newColor,
                roughness: 0.7,
                metalness: 0.2,
                side: THREE.DoubleSide
              });
            } else {
              // ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ texture ‡πÉ‡∏´‡πâ‡∏õ‡∏£‡∏±‡∏ö‡∏Ñ‡πà‡∏≤
              mat.roughness = mat.roughness || 0.7;
              mat.metalness = mat.metalness || 0.2;
              mat.needsUpdate = true;
            }
          }
        }
      });
      
      scene.add(model);
      
      document.getElementById('info').innerHTML = `
        ‡πÇ‡∏°‡πÄ‡∏î‡∏• 3D ‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏™‡∏£‡πá‡∏à‡πÅ‡∏•‡πâ‡∏ß!<br>
        <small>‡∏û‡∏ö ${meshCount} meshes<br>
        ${materialInfo.slice(0, 5).join('<br>')}
        ${materialInfo.length > 5 ? '<br>...' : ''}</small>
      `;
      
      console.log('=== ‡πÇ‡∏°‡πÄ‡∏î‡∏•‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏™‡∏£‡πá‡∏à ===');
      console.log('‡∏à‡∏≥‡∏ô‡∏ß‡∏ô meshes:', meshCount);
      console.log('‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î:', materialInfo);
    },
    function (progress) {
      const percent = (progress.loaded / progress.total * 100).toFixed(0);
      document.getElementById('info').innerHTML = `
        ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏• 3D... ${percent}%<br>
        <small>‡πÉ‡∏ä‡πâ‡πÄ‡∏°‡∏≤‡∏™‡πå‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏´‡∏°‡∏∏‡∏ô‡πÅ‡∏•‡∏∞‡∏ã‡∏π‡∏°</small>
      `;
    },
    function (error) {
      console.error('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏•:', error);
      document.getElementById('info').innerHTML = `
        ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏•<br>
        <small>‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö URL ‡∏Ç‡∏≠‡∏á‡πÑ‡∏ü‡∏•‡πå</small>
      `;
    }
  );

  // Resize
  addEventListener('resize', () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });

  // Render Loop
  function animate() {
    controls.update();
    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  }
  
  animate();
</script>
</body>
</html>